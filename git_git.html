<h1 id="git-for-windows-インストール">Git for Windows インストール</h1>
<h2 id="git-for-windows">Git for Windows</h2>
<p>https://git-for-windows.github.io/</p>
<h2 id="日本語化">日本語化</h2>
<ul class="incremental">
<li>C:Files64-guimsgs フォルダ作成</li>
<li>contents.msg を配置</li>
</ul>
<h2 id="git-repo.-のクローン">Git Repo. のクローン</h2>
<div class="figure">
<img src="git/02.png" />
</div>
<p>レポジトリを置くフォルダを開く 既存レポジトリを複製する</p>
<p><img src="git/03.png" /> * ソースの位置：http://～/hogehoge.git * 先ディレクトリ：今開いているフォルダ</p>
<h2 id="通常時作業">通常時作業</h2>
<p>http://facebookdevnice.blogspot.jp/2012/06/git-gui-git.html</p>
<ul class="incremental">
<li>git pull origin</li>
<li>git add .</li>
<li>git commit -m &quot;<strong><em>comit message</em></strong>&quot;</li>
<li>git push origin master</li>
</ul>
<h2 id="gitその傾向と対策">gitその傾向と対策</h2>
<h3 id="一連の流れ">一連の流れ</h3>
<ol class="incremental" style="list-style-type: decimal">
<li><p>git repository を作る</p></li>
<li><p>remote に push する</p>
<p>$ git push -u origin master</p></li>
<li><p>remote から一度 pull する</p>
<p>$ git pull origin</p></li>
<li><p>branch を切る</p>
<p>$ git branch hogehoge $ git branch &gt; * master &gt; hogehoge $ git checkout hogehoge $ git branch &gt; master &gt; * hogehoge</p></li>
</ol>
<p>　より簡単に branch 切った後そちらに移るには</p>
<pre><code> $ git checkout -b hogehoge</code></pre>
<ol class="incremental" start="5" style="list-style-type: decimal">
<li><p>作成・修正する -&gt; コミット</p>
<p>$ git commit -a -m &quot;comment&quot;</p></li>
<li><p>リモートへプシュする前に、リモートと同期 一人なら関係なさそうな気もするが・・・これでmaster branchを最新の状況にする。</p>
<p>$ git checkout master $ git pull origin master</p></li>
</ol>
<h3 id="merge-する">merge する</h3>
<ol class="incremental" start="7" style="list-style-type: decimal">
<li>master に merge する</li>
</ol>
<p>7-1) --ff (default) hogehoge に master を移動させる感じ？ログが一本になる。作業用ブランチがあったことをログに残さない。</p>
<pre><code> $ git merge hogehoge
 $ git merge --ff hogehoge //default（上と同じ)</code></pre>
<p>7-2) --no-ff hogehoge の結果を master に繰り込む感じ？作業用ブランチがあったことを残す。基本的にはこれかな？</p>
<pre><code> $ git merge --no-ff hogehoge</code></pre>
<p>7-3) --squach hogehoge での変更を master に適用して、hogehoge がなかったことに。１コミットとして考えられる。 merge後、commit が必要。</p>
<pre><code> $ git merge --squash hogehoge
 $ git commit</code></pre>
<p><a href="http://d.hatena.ne.jp/sinsoku/20111025/1319497900">図で分かるgit-mergeの--ff, --no-ff, --squashの違い - アジャイルSEを目指すブログ</a></p>
<h3 id="rebase-する">rebase する</h3>
<ol class="incremental" start="7" style="list-style-type: decimal">
<li><p>最新のmasterを作業用ブランチにリベース</p>
<p>$ git checkout hogehoge $ git rebase master</p></li>
<li><p>作業用ブランチを最新のmasterにリベース　master = 作業用の位置合わせ（コミットグラフ的にも）</p>
<p>$ git checkout master $ git rebase hogehoge</p>
<p>$ git merge --ff-only hogehoge //こちらでもよい</p></li>
<li><p>リモートへpush</p>
<p>$ git push origin master</p></li>
</ol>
<p><a href="http://d.hatena.ne.jp/ogin_s57/20130624/1372069907">GITでリモートブランチへpushする前にやっておくべきこと - ITエンジニアとして生きる</a></p>
<h3 id="mergeとrebase-の違いとは">mergeとrebase の違いとは</h3>
<blockquote>
<p>&quot;リベースの操作によって、bugfixブランチ上にあった2つのコミットは改変された（一度、破棄され、新たに作成された）ということがわかります。 マージの場合と異なり、リベースはコミットを改変する作業なのです。&quot;</p>
</blockquote>
<p>merge は簡単であるし、統合前ブランチのコミットも改変されず、ブランチの情報を分離して保持することが出来る。しかし、履歴が複雑化する原因となる。rebaseは履歴がシンプルであるが、競合時対処が難しく、コミット改変を行ってしまう点に注意。</p>
<p><a href="http://powerful-code.com/blog/2012/11/merge-or-rebase/">[Git] 使い分けできていますか？マージ（merge）&amp;リベース（rebase）再入門 - The Powerful Code</a></p>
